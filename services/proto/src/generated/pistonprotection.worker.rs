// This file is @generated by prost-build.
/// Worker node registration
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Worker {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub node_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub hostname: ::prost::alloc::string::String,
    /// Network interfaces
    #[prost(message, repeated, tag = "4")]
    pub interfaces: ::prost::alloc::vec::Vec<NetworkInterface>,
    /// Capabilities
    #[prost(message, optional, tag = "5")]
    pub capabilities: ::core::option::Option<WorkerCapabilities>,
    /// Status
    #[prost(enumeration = "WorkerStatus", tag = "6")]
    pub status: i32,
    /// Labels
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Timestamps
    #[prost(message, optional, tag = "8")]
    pub registered_at: ::core::option::Option<super::common::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub last_heartbeat: ::core::option::Option<super::common::Timestamp>,
}
/// Network interface on worker
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NetworkInterface {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub ip_address: ::core::option::Option<super::common::IpAddress>,
    #[prost(string, tag = "3")]
    pub mac_address: ::prost::alloc::string::String,
    /// XDP program status
    #[prost(message, optional, tag = "4")]
    pub xdp_status: ::core::option::Option<XdpStatus>,
    /// Interface stats
    #[prost(uint64, tag = "5")]
    pub rx_bytes: u64,
    #[prost(uint64, tag = "6")]
    pub tx_bytes: u64,
    #[prost(uint64, tag = "7")]
    pub rx_packets: u64,
    #[prost(uint64, tag = "8")]
    pub tx_packets: u64,
    #[prost(uint64, tag = "9")]
    pub rx_dropped: u64,
    #[prost(uint64, tag = "10")]
    pub tx_dropped: u64,
}
/// XDP program status
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct XdpStatus {
    #[prost(bool, tag = "1")]
    pub attached: bool,
    #[prost(string, tag = "2")]
    pub program_id: ::prost::alloc::string::String,
    #[prost(enumeration = "XdpMode", tag = "3")]
    pub mode: i32,
    #[prost(uint32, tag = "4")]
    pub program_version: u32,
    #[prost(message, optional, tag = "5")]
    pub attached_at: ::core::option::Option<super::common::Timestamp>,
}
/// Worker capabilities
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WorkerCapabilities {
    /// XDP support
    #[prost(bool, tag = "1")]
    pub xdp_native: bool,
    #[prost(bool, tag = "2")]
    pub xdp_driver: bool,
    #[prost(bool, tag = "3")]
    pub xdp_offload: bool,
    /// eBPF features
    #[prost(string, repeated, tag = "4")]
    pub bpf_helpers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint32, tag = "5")]
    pub max_bpf_stack_size: u32,
    #[prost(uint32, tag = "6")]
    pub max_map_entries: u32,
    /// Hardware
    #[prost(uint32, tag = "7")]
    pub cpu_cores: u32,
    #[prost(uint64, tag = "8")]
    pub memory_bytes: u64,
    #[prost(string, repeated, tag = "9")]
    pub network_drivers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Kernel version
    #[prost(string, tag = "10")]
    pub kernel_version: ::prost::alloc::string::String,
    #[prost(uint32, tag = "11")]
    pub kernel_major: u32,
    #[prost(uint32, tag = "12")]
    pub kernel_minor: u32,
}
/// Filter configuration for worker
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterConfig {
    #[prost(string, tag = "1")]
    pub config_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub version: u32,
    /// Backends to protect
    #[prost(message, repeated, tag = "3")]
    pub backends: ::prost::alloc::vec::Vec<BackendFilter>,
    /// Global settings
    #[prost(message, optional, tag = "4")]
    pub global: ::core::option::Option<GlobalFilterSettings>,
    /// Generated at
    #[prost(message, optional, tag = "5")]
    pub generated_at: ::core::option::Option<super::common::Timestamp>,
}
/// Backend-specific filter configuration
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackendFilter {
    #[prost(string, tag = "1")]
    pub backend_id: ::prost::alloc::string::String,
    /// Destination IPs/ports for this backend
    #[prost(message, repeated, tag = "2")]
    pub destination_ips: ::prost::alloc::vec::Vec<super::common::IpNetwork>,
    #[prost(message, repeated, tag = "3")]
    pub destination_ports: ::prost::alloc::vec::Vec<super::common::PortRange>,
    /// Protocol
    #[prost(enumeration = "super::common::L7Protocol", tag = "4")]
    pub protocol: i32,
    /// Protection settings
    #[prost(message, optional, tag = "5")]
    pub protection: ::core::option::Option<ProtectionConfig>,
    /// Filter rules
    #[prost(message, repeated, tag = "6")]
    pub rules: ::prost::alloc::vec::Vec<super::filter::FilterRule>,
}
/// Protection configuration
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProtectionConfig {
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    /// 0-5
    #[prost(uint32, tag = "2")]
    pub level: u32,
    /// Rate limits (converted to XDP-friendly format)
    #[prost(message, optional, tag = "3")]
    pub global_rate: ::core::option::Option<RateLimitConfig>,
    #[prost(message, optional, tag = "4")]
    pub per_ip_rate: ::core::option::Option<RateLimitConfig>,
    /// GeoIP blocking
    ///
    /// GeoIP database country IDs
    #[prost(uint32, repeated, tag = "5")]
    pub blocked_country_ids: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "6")]
    pub allowed_country_ids: ::prost::alloc::vec::Vec<u32>,
    /// Challenge settings
    #[prost(bool, tag = "7")]
    pub challenge_enabled: bool,
    #[prost(uint32, tag = "8")]
    pub challenge_threshold: u32,
}
/// Rate limit config for XDP
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RateLimitConfig {
    #[prost(uint64, tag = "1")]
    pub tokens_per_second: u64,
    #[prost(uint64, tag = "2")]
    pub bucket_size: u64,
}
/// Global filter settings
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GlobalFilterSettings {
    /// Default action for unmatched traffic
    #[prost(enumeration = "super::common::Action", tag = "1")]
    pub default_action: i32,
    /// Sampling rate for logging (1 in N packets)
    #[prost(uint32, tag = "2")]
    pub log_sampling_rate: u32,
    /// Emergency mode settings
    #[prost(bool, tag = "3")]
    pub emergency_mode: bool,
    #[prost(uint64, tag = "4")]
    pub emergency_pps_threshold: u64,
}
/// eBPF map update
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MapUpdate {
    #[prost(string, tag = "1")]
    pub map_name: ::prost::alloc::string::String,
    #[prost(enumeration = "MapOperation", tag = "2")]
    pub operation: i32,
    #[prost(bytes = "vec", tag = "3")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "5")]
    pub flags: u32,
}
/// Connection tracking entry
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnTrackEntry {
    #[prost(message, optional, tag = "1")]
    pub src_ip: ::core::option::Option<super::common::IpAddress>,
    #[prost(uint32, tag = "2")]
    pub src_port: u32,
    #[prost(message, optional, tag = "3")]
    pub dst_ip: ::core::option::Option<super::common::IpAddress>,
    #[prost(uint32, tag = "4")]
    pub dst_port: u32,
    #[prost(enumeration = "super::common::Protocol", tag = "5")]
    pub protocol: i32,
    /// State
    #[prost(enumeration = "ConnTrackState", tag = "6")]
    pub state: i32,
    #[prost(uint64, tag = "7")]
    pub packets: u64,
    #[prost(uint64, tag = "8")]
    pub bytes: u64,
    /// Timestamps
    #[prost(message, optional, tag = "9")]
    pub created_at: ::core::option::Option<super::common::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub last_seen: ::core::option::Option<super::common::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub expires_at: ::core::option::Option<super::common::Timestamp>,
}
/// Blocked IP entry
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BlockedIp {
    #[prost(message, optional, tag = "1")]
    pub ip: ::core::option::Option<super::common::IpAddress>,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub packets_blocked: u64,
    #[prost(message, optional, tag = "4")]
    pub blocked_at: ::core::option::Option<super::common::Timestamp>,
    /// 0 = permanent
    #[prost(message, optional, tag = "5")]
    pub expires_at: ::core::option::Option<super::common::Timestamp>,
}
/// Request/Response messages
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterRequest {
    #[prost(message, optional, tag = "1")]
    pub worker: ::core::option::Option<Worker>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterResponse {
    #[prost(string, tag = "1")]
    pub worker_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub initial_config: ::core::option::Option<FilterConfig>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HeartbeatRequest {
    #[prost(string, tag = "1")]
    pub worker_id: ::prost::alloc::string::String,
    #[prost(enumeration = "WorkerStatus", tag = "2")]
    pub status: i32,
    #[prost(message, optional, tag = "3")]
    pub metrics: ::core::option::Option<WorkerMetrics>,
    /// Current config version for checking if update is needed
    #[prost(uint32, tag = "4")]
    pub current_config_version: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerMetrics {
    #[prost(float, tag = "1")]
    pub cpu_percent: f32,
    #[prost(float, tag = "2")]
    pub memory_percent: f32,
    #[prost(message, repeated, tag = "3")]
    pub interfaces: ::prost::alloc::vec::Vec<InterfaceMetrics>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InterfaceMetrics {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub rx_pps: u64,
    #[prost(uint64, tag = "3")]
    pub tx_pps: u64,
    #[prost(uint64, tag = "4")]
    pub rx_bps: u64,
    #[prost(uint64, tag = "5")]
    pub tx_bps: u64,
    #[prost(uint64, tag = "6")]
    pub xdp_pass: u64,
    #[prost(uint64, tag = "7")]
    pub xdp_drop: u64,
    #[prost(uint64, tag = "8")]
    pub xdp_redirect: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HeartbeatResponse {
    #[prost(bool, tag = "1")]
    pub config_update_available: bool,
    #[prost(uint32, tag = "2")]
    pub latest_config_version: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeregisterRequest {
    #[prost(string, tag = "1")]
    pub worker_id: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeregisterResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetConfigRequest {
    #[prost(string, tag = "1")]
    pub worker_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub current_version: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConfigResponse {
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<FilterConfig>,
    #[prost(bool, tag = "2")]
    pub up_to_date: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StreamConfigRequest {
    #[prost(string, tag = "1")]
    pub worker_id: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyMapUpdatesRequest {
    #[prost(string, tag = "1")]
    pub worker_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub updates: ::prost::alloc::vec::Vec<MapUpdate>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ApplyMapUpdatesResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, repeated, tag = "2")]
    pub errors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportMetricsRequest {
    #[prost(string, tag = "1")]
    pub worker_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub backend_metrics: ::prost::alloc::vec::Vec<BackendMetrics>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackendMetrics {
    #[prost(string, tag = "1")]
    pub backend_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub packets_in: u64,
    #[prost(uint64, tag = "3")]
    pub packets_out: u64,
    #[prost(uint64, tag = "4")]
    pub bytes_in: u64,
    #[prost(uint64, tag = "5")]
    pub bytes_out: u64,
    #[prost(uint64, tag = "6")]
    pub packets_dropped: u64,
    #[prost(uint64, tag = "7")]
    pub packets_challenged: u64,
    #[prost(map = "string, uint64", tag = "8")]
    pub drops_by_reason: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        u64,
    >,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReportMetricsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportAttackRequest {
    #[prost(string, tag = "1")]
    pub worker_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub backend_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub attack_type: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub attack_pps: u64,
    #[prost(uint64, tag = "5")]
    pub attack_bps: u64,
    #[prost(message, repeated, tag = "6")]
    pub sources: ::prost::alloc::vec::Vec<AttackSourceInfo>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AttackSourceInfo {
    #[prost(message, optional, tag = "1")]
    pub ip: ::core::option::Option<super::common::IpAddress>,
    #[prost(uint64, tag = "2")]
    pub packets: u64,
    #[prost(uint64, tag = "3")]
    pub bytes: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportAttackResponse {
    /// Response actions
    #[prost(message, repeated, tag = "1")]
    pub block_updates: ::prost::alloc::vec::Vec<MapUpdate>,
    #[prost(bool, tag = "2")]
    pub escalate_protection: bool,
    #[prost(uint32, tag = "3")]
    pub new_protection_level: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnTrackSync {
    #[prost(enumeration = "conn_track_sync::SyncType", tag = "1")]
    pub r#type: i32,
    #[prost(message, repeated, tag = "2")]
    pub entries: ::prost::alloc::vec::Vec<ConnTrackEntry>,
}
/// Nested message and enum types in `ConnTrackSync`.
pub mod conn_track_sync {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SyncType {
        Unspecified = 0,
        Full = 1,
        Update = 2,
        Delete = 3,
    }
    impl SyncType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SYNC_TYPE_UNSPECIFIED",
                Self::Full => "SYNC_TYPE_FULL",
                Self::Update => "SYNC_TYPE_UPDATE",
                Self::Delete => "SYNC_TYPE_DELETE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SYNC_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "SYNC_TYPE_FULL" => Some(Self::Full),
                "SYNC_TYPE_UPDATE" => Some(Self::Update),
                "SYNC_TYPE_DELETE" => Some(Self::Delete),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBlockedIpsRequest {
    #[prost(string, tag = "1")]
    pub worker_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<super::common::Pagination>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlockedIpsResponse {
    #[prost(message, repeated, tag = "1")]
    pub ips: ::prost::alloc::vec::Vec<BlockedIp>,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<super::common::PaginationInfo>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BlockIpRequest {
    #[prost(message, optional, tag = "1")]
    pub ip: ::core::option::Option<super::common::IpAddress>,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
    /// 0 = permanent
    #[prost(uint32, tag = "3")]
    pub duration_seconds: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BlockIpResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnblockIpRequest {
    #[prost(message, optional, tag = "1")]
    pub ip: ::core::option::Option<super::common::IpAddress>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnblockIpResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetXdpStatsRequest {
    #[prost(string, tag = "1")]
    pub worker_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub interface_name: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetXdpStatsResponse {
    #[prost(uint64, tag = "1")]
    pub packets_processed: u64,
    #[prost(uint64, tag = "2")]
    pub packets_passed: u64,
    #[prost(uint64, tag = "3")]
    pub packets_dropped: u64,
    #[prost(uint64, tag = "4")]
    pub packets_redirected: u64,
    #[prost(uint64, tag = "5")]
    pub packets_aborted: u64,
    #[prost(map = "string, uint64", tag = "6")]
    pub per_cpu_stats: ::std::collections::HashMap<::prost::alloc::string::String, u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DumpMapsRequest {
    #[prost(string, tag = "1")]
    pub worker_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub map_name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub max_entries: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DumpMapsResponse {
    #[prost(string, tag = "1")]
    pub map_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub entries: ::prost::alloc::vec::Vec<MapEntry>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MapEntry {
    #[prost(bytes = "vec", tag = "1")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
/// XDP attachment mode
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum XdpMode {
    Unspecified = 0,
    /// Hardware offload (best performance)
    Native = 1,
    /// Driver level
    Driver = 2,
    /// Software fallback (slowest)
    Generic = 3,
}
impl XdpMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "XDP_MODE_UNSPECIFIED",
            Self::Native => "XDP_MODE_NATIVE",
            Self::Driver => "XDP_MODE_DRIVER",
            Self::Generic => "XDP_MODE_GENERIC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "XDP_MODE_UNSPECIFIED" => Some(Self::Unspecified),
            "XDP_MODE_NATIVE" => Some(Self::Native),
            "XDP_MODE_DRIVER" => Some(Self::Driver),
            "XDP_MODE_GENERIC" => Some(Self::Generic),
            _ => None,
        }
    }
}
/// Worker status
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WorkerStatus {
    Unspecified = 0,
    Registering = 1,
    Ready = 2,
    Draining = 3,
    Unhealthy = 4,
    Offline = 5,
}
impl WorkerStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "WORKER_STATUS_UNSPECIFIED",
            Self::Registering => "WORKER_STATUS_REGISTERING",
            Self::Ready => "WORKER_STATUS_READY",
            Self::Draining => "WORKER_STATUS_DRAINING",
            Self::Unhealthy => "WORKER_STATUS_UNHEALTHY",
            Self::Offline => "WORKER_STATUS_OFFLINE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WORKER_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "WORKER_STATUS_REGISTERING" => Some(Self::Registering),
            "WORKER_STATUS_READY" => Some(Self::Ready),
            "WORKER_STATUS_DRAINING" => Some(Self::Draining),
            "WORKER_STATUS_UNHEALTHY" => Some(Self::Unhealthy),
            "WORKER_STATUS_OFFLINE" => Some(Self::Offline),
            _ => None,
        }
    }
}
/// Map operation type
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MapOperation {
    Unspecified = 0,
    Update = 1,
    Delete = 2,
    Lookup = 3,
}
impl MapOperation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "MAP_OPERATION_UNSPECIFIED",
            Self::Update => "MAP_OPERATION_UPDATE",
            Self::Delete => "MAP_OPERATION_DELETE",
            Self::Lookup => "MAP_OPERATION_LOOKUP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MAP_OPERATION_UNSPECIFIED" => Some(Self::Unspecified),
            "MAP_OPERATION_UPDATE" => Some(Self::Update),
            "MAP_OPERATION_DELETE" => Some(Self::Delete),
            "MAP_OPERATION_LOOKUP" => Some(Self::Lookup),
            _ => None,
        }
    }
}
/// Connection tracking state
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConnTrackState {
    Unspecified = 0,
    New = 1,
    Established = 2,
    Related = 3,
    Closing = 4,
    Closed = 5,
}
impl ConnTrackState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CONN_TRACK_STATE_UNSPECIFIED",
            Self::New => "CONN_TRACK_STATE_NEW",
            Self::Established => "CONN_TRACK_STATE_ESTABLISHED",
            Self::Related => "CONN_TRACK_STATE_RELATED",
            Self::Closing => "CONN_TRACK_STATE_CLOSING",
            Self::Closed => "CONN_TRACK_STATE_CLOSED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONN_TRACK_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "CONN_TRACK_STATE_NEW" => Some(Self::New),
            "CONN_TRACK_STATE_ESTABLISHED" => Some(Self::Established),
            "CONN_TRACK_STATE_RELATED" => Some(Self::Related),
            "CONN_TRACK_STATE_CLOSING" => Some(Self::Closing),
            "CONN_TRACK_STATE_CLOSED" => Some(Self::Closed),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod worker_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Worker service for control plane communication
    #[derive(Debug, Clone)]
    pub struct WorkerServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl WorkerServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> WorkerServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WorkerServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            WorkerServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Worker lifecycle
        pub async fn register(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.worker.WorkerService/Register",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("pistonprotection.worker.WorkerService", "Register"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn heartbeat(
            &mut self,
            request: impl tonic::IntoRequest<super::HeartbeatRequest>,
        ) -> std::result::Result<
            tonic::Response<super::HeartbeatResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.worker.WorkerService/Heartbeat",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("pistonprotection.worker.WorkerService", "Heartbeat"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn deregister(
            &mut self,
            request: impl tonic::IntoRequest<super::DeregisterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeregisterResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.worker.WorkerService/Deregister",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pistonprotection.worker.WorkerService",
                        "Deregister",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Configuration
        pub async fn get_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetConfigResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.worker.WorkerService/GetConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("pistonprotection.worker.WorkerService", "GetConfig"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn stream_config(
            &mut self,
            request: impl tonic::IntoRequest<super::StreamConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::FilterConfig>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.worker.WorkerService/StreamConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pistonprotection.worker.WorkerService",
                        "StreamConfig",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Map updates (for incremental updates)
        pub async fn apply_map_updates(
            &mut self,
            request: impl tonic::IntoRequest<super::ApplyMapUpdatesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ApplyMapUpdatesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.worker.WorkerService/ApplyMapUpdates",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pistonprotection.worker.WorkerService",
                        "ApplyMapUpdates",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Reporting
        pub async fn report_metrics(
            &mut self,
            request: impl tonic::IntoRequest<super::ReportMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReportMetricsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.worker.WorkerService/ReportMetrics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pistonprotection.worker.WorkerService",
                        "ReportMetrics",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn report_attack(
            &mut self,
            request: impl tonic::IntoRequest<super::ReportAttackRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReportAttackResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.worker.WorkerService/ReportAttack",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pistonprotection.worker.WorkerService",
                        "ReportAttack",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Connection tracking
        pub async fn sync_conn_track(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::ConnTrackSync>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ConnTrackSync>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.worker.WorkerService/SyncConnTrack",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pistonprotection.worker.WorkerService",
                        "SyncConnTrack",
                    ),
                );
            self.inner.streaming(req, path, codec).await
        }
        /// Blocked IPs
        pub async fn get_blocked_ips(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBlockedIpsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBlockedIpsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.worker.WorkerService/GetBlockedIps",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pistonprotection.worker.WorkerService",
                        "GetBlockedIps",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_ip(
            &mut self,
            request: impl tonic::IntoRequest<super::BlockIpRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BlockIpResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.worker.WorkerService/BlockIp",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("pistonprotection.worker.WorkerService", "BlockIp"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn unblock_ip(
            &mut self,
            request: impl tonic::IntoRequest<super::UnblockIpRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UnblockIpResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.worker.WorkerService/UnblockIp",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("pistonprotection.worker.WorkerService", "UnblockIp"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Debugging
        pub async fn get_xdp_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::GetXdpStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetXdpStatsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.worker.WorkerService/GetXdpStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pistonprotection.worker.WorkerService",
                        "GetXdpStats",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn dump_maps(
            &mut self,
            request: impl tonic::IntoRequest<super::DumpMapsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DumpMapsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.worker.WorkerService/DumpMaps",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("pistonprotection.worker.WorkerService", "DumpMaps"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod worker_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with WorkerServiceServer.
    #[async_trait]
    pub trait WorkerService: std::marker::Send + std::marker::Sync + 'static {
        /// Worker lifecycle
        async fn register(
            &self,
            request: tonic::Request<super::RegisterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterResponse>,
            tonic::Status,
        >;
        async fn heartbeat(
            &self,
            request: tonic::Request<super::HeartbeatRequest>,
        ) -> std::result::Result<
            tonic::Response<super::HeartbeatResponse>,
            tonic::Status,
        >;
        async fn deregister(
            &self,
            request: tonic::Request<super::DeregisterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeregisterResponse>,
            tonic::Status,
        >;
        /// Configuration
        async fn get_config(
            &self,
            request: tonic::Request<super::GetConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetConfigResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the StreamConfig method.
        type StreamConfigStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::FilterConfig, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn stream_config(
            &self,
            request: tonic::Request<super::StreamConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::StreamConfigStream>,
            tonic::Status,
        >;
        /// Map updates (for incremental updates)
        async fn apply_map_updates(
            &self,
            request: tonic::Request<super::ApplyMapUpdatesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ApplyMapUpdatesResponse>,
            tonic::Status,
        >;
        /// Reporting
        async fn report_metrics(
            &self,
            request: tonic::Request<super::ReportMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReportMetricsResponse>,
            tonic::Status,
        >;
        async fn report_attack(
            &self,
            request: tonic::Request<super::ReportAttackRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReportAttackResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the SyncConnTrack method.
        type SyncConnTrackStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ConnTrackSync, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Connection tracking
        async fn sync_conn_track(
            &self,
            request: tonic::Request<tonic::Streaming<super::ConnTrackSync>>,
        ) -> std::result::Result<
            tonic::Response<Self::SyncConnTrackStream>,
            tonic::Status,
        >;
        /// Blocked IPs
        async fn get_blocked_ips(
            &self,
            request: tonic::Request<super::GetBlockedIpsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBlockedIpsResponse>,
            tonic::Status,
        >;
        async fn block_ip(
            &self,
            request: tonic::Request<super::BlockIpRequest>,
        ) -> std::result::Result<tonic::Response<super::BlockIpResponse>, tonic::Status>;
        async fn unblock_ip(
            &self,
            request: tonic::Request<super::UnblockIpRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UnblockIpResponse>,
            tonic::Status,
        >;
        /// Debugging
        async fn get_xdp_stats(
            &self,
            request: tonic::Request<super::GetXdpStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetXdpStatsResponse>,
            tonic::Status,
        >;
        async fn dump_maps(
            &self,
            request: tonic::Request<super::DumpMapsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DumpMapsResponse>,
            tonic::Status,
        >;
    }
    /// Worker service for control plane communication
    #[derive(Debug)]
    pub struct WorkerServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> WorkerServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for WorkerServiceServer<T>
    where
        T: WorkerService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/pistonprotection.worker.WorkerService/Register" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterSvc<T: WorkerService>(pub Arc<T>);
                    impl<
                        T: WorkerService,
                    > tonic::server::UnaryService<super::RegisterRequest>
                    for RegisterSvc<T> {
                        type Response = super::RegisterResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RegisterRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as WorkerService>::register(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegisterSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pistonprotection.worker.WorkerService/Heartbeat" => {
                    #[allow(non_camel_case_types)]
                    struct HeartbeatSvc<T: WorkerService>(pub Arc<T>);
                    impl<
                        T: WorkerService,
                    > tonic::server::UnaryService<super::HeartbeatRequest>
                    for HeartbeatSvc<T> {
                        type Response = super::HeartbeatResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::HeartbeatRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as WorkerService>::heartbeat(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = HeartbeatSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pistonprotection.worker.WorkerService/Deregister" => {
                    #[allow(non_camel_case_types)]
                    struct DeregisterSvc<T: WorkerService>(pub Arc<T>);
                    impl<
                        T: WorkerService,
                    > tonic::server::UnaryService<super::DeregisterRequest>
                    for DeregisterSvc<T> {
                        type Response = super::DeregisterResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeregisterRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as WorkerService>::deregister(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeregisterSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pistonprotection.worker.WorkerService/GetConfig" => {
                    #[allow(non_camel_case_types)]
                    struct GetConfigSvc<T: WorkerService>(pub Arc<T>);
                    impl<
                        T: WorkerService,
                    > tonic::server::UnaryService<super::GetConfigRequest>
                    for GetConfigSvc<T> {
                        type Response = super::GetConfigResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as WorkerService>::get_config(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetConfigSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pistonprotection.worker.WorkerService/StreamConfig" => {
                    #[allow(non_camel_case_types)]
                    struct StreamConfigSvc<T: WorkerService>(pub Arc<T>);
                    impl<
                        T: WorkerService,
                    > tonic::server::ServerStreamingService<super::StreamConfigRequest>
                    for StreamConfigSvc<T> {
                        type Response = super::FilterConfig;
                        type ResponseStream = T::StreamConfigStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StreamConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as WorkerService>::stream_config(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StreamConfigSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pistonprotection.worker.WorkerService/ApplyMapUpdates" => {
                    #[allow(non_camel_case_types)]
                    struct ApplyMapUpdatesSvc<T: WorkerService>(pub Arc<T>);
                    impl<
                        T: WorkerService,
                    > tonic::server::UnaryService<super::ApplyMapUpdatesRequest>
                    for ApplyMapUpdatesSvc<T> {
                        type Response = super::ApplyMapUpdatesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ApplyMapUpdatesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as WorkerService>::apply_map_updates(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ApplyMapUpdatesSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pistonprotection.worker.WorkerService/ReportMetrics" => {
                    #[allow(non_camel_case_types)]
                    struct ReportMetricsSvc<T: WorkerService>(pub Arc<T>);
                    impl<
                        T: WorkerService,
                    > tonic::server::UnaryService<super::ReportMetricsRequest>
                    for ReportMetricsSvc<T> {
                        type Response = super::ReportMetricsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReportMetricsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as WorkerService>::report_metrics(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ReportMetricsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pistonprotection.worker.WorkerService/ReportAttack" => {
                    #[allow(non_camel_case_types)]
                    struct ReportAttackSvc<T: WorkerService>(pub Arc<T>);
                    impl<
                        T: WorkerService,
                    > tonic::server::UnaryService<super::ReportAttackRequest>
                    for ReportAttackSvc<T> {
                        type Response = super::ReportAttackResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReportAttackRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as WorkerService>::report_attack(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ReportAttackSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pistonprotection.worker.WorkerService/SyncConnTrack" => {
                    #[allow(non_camel_case_types)]
                    struct SyncConnTrackSvc<T: WorkerService>(pub Arc<T>);
                    impl<
                        T: WorkerService,
                    > tonic::server::StreamingService<super::ConnTrackSync>
                    for SyncConnTrackSvc<T> {
                        type Response = super::ConnTrackSync;
                        type ResponseStream = T::SyncConnTrackStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::ConnTrackSync>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as WorkerService>::sync_conn_track(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SyncConnTrackSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pistonprotection.worker.WorkerService/GetBlockedIps" => {
                    #[allow(non_camel_case_types)]
                    struct GetBlockedIpsSvc<T: WorkerService>(pub Arc<T>);
                    impl<
                        T: WorkerService,
                    > tonic::server::UnaryService<super::GetBlockedIpsRequest>
                    for GetBlockedIpsSvc<T> {
                        type Response = super::GetBlockedIpsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetBlockedIpsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as WorkerService>::get_blocked_ips(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetBlockedIpsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pistonprotection.worker.WorkerService/BlockIp" => {
                    #[allow(non_camel_case_types)]
                    struct BlockIpSvc<T: WorkerService>(pub Arc<T>);
                    impl<
                        T: WorkerService,
                    > tonic::server::UnaryService<super::BlockIpRequest>
                    for BlockIpSvc<T> {
                        type Response = super::BlockIpResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BlockIpRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as WorkerService>::block_ip(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BlockIpSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pistonprotection.worker.WorkerService/UnblockIp" => {
                    #[allow(non_camel_case_types)]
                    struct UnblockIpSvc<T: WorkerService>(pub Arc<T>);
                    impl<
                        T: WorkerService,
                    > tonic::server::UnaryService<super::UnblockIpRequest>
                    for UnblockIpSvc<T> {
                        type Response = super::UnblockIpResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UnblockIpRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as WorkerService>::unblock_ip(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UnblockIpSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pistonprotection.worker.WorkerService/GetXdpStats" => {
                    #[allow(non_camel_case_types)]
                    struct GetXdpStatsSvc<T: WorkerService>(pub Arc<T>);
                    impl<
                        T: WorkerService,
                    > tonic::server::UnaryService<super::GetXdpStatsRequest>
                    for GetXdpStatsSvc<T> {
                        type Response = super::GetXdpStatsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetXdpStatsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as WorkerService>::get_xdp_stats(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetXdpStatsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pistonprotection.worker.WorkerService/DumpMaps" => {
                    #[allow(non_camel_case_types)]
                    struct DumpMapsSvc<T: WorkerService>(pub Arc<T>);
                    impl<
                        T: WorkerService,
                    > tonic::server::UnaryService<super::DumpMapsRequest>
                    for DumpMapsSvc<T> {
                        type Response = super::DumpMapsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DumpMapsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as WorkerService>::dump_maps(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DumpMapsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for WorkerServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "pistonprotection.worker.WorkerService";
    impl<T> tonic::server::NamedService for WorkerServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
