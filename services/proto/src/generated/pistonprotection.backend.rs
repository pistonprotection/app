// This file is @generated by prost-build.
/// Backend represents a protected origin server
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Backend {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub organization_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    /// Backend type
    #[prost(enumeration = "BackendType", tag = "5")]
    pub r#type: i32,
    /// Backend addresses (origins)
    #[prost(message, repeated, tag = "6")]
    pub origins: ::prost::alloc::vec::Vec<Origin>,
    /// Load balancing configuration
    #[prost(message, optional, tag = "7")]
    pub load_balancer: ::core::option::Option<LoadBalancerConfig>,
    /// Health check configuration
    #[prost(message, optional, tag = "8")]
    pub health_check: ::core::option::Option<HealthCheckConfig>,
    /// Protection settings
    #[prost(message, optional, tag = "9")]
    pub protection: ::core::option::Option<ProtectionSettings>,
    /// Domain names pointing to this backend
    #[prost(string, repeated, tag = "10")]
    pub domains: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Backend status
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<BackendStatus>,
    /// Timestamps
    #[prost(message, optional, tag = "12")]
    pub created_at: ::core::option::Option<super::common::Timestamp>,
    #[prost(message, optional, tag = "13")]
    pub updated_at: ::core::option::Option<super::common::Timestamp>,
    /// Tags for organization
    #[prost(map = "string, string", tag = "14")]
    pub tags: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Origin server
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Origin {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Address
    #[prost(message, optional, tag = "3")]
    pub address: ::core::option::Option<super::common::IpAddress>,
    #[prost(uint32, tag = "4")]
    pub port: u32,
    /// Or use hostname
    #[prost(string, tag = "5")]
    pub hostname: ::prost::alloc::string::String,
    /// Weight for load balancing
    #[prost(uint32, tag = "6")]
    pub weight: u32,
    /// Priority for failover
    #[prost(uint32, tag = "7")]
    pub priority: u32,
    /// Origin-specific settings
    #[prost(message, optional, tag = "8")]
    pub settings: ::core::option::Option<OriginSettings>,
    /// Health status
    #[prost(enumeration = "super::common::HealthStatus", tag = "9")]
    pub health_status: i32,
    /// Whether origin is enabled
    #[prost(bool, tag = "10")]
    pub enabled: bool,
}
/// Origin-specific settings
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OriginSettings {
    /// Connection settings
    #[prost(uint32, tag = "1")]
    pub connect_timeout_ms: u32,
    #[prost(uint32, tag = "2")]
    pub read_timeout_ms: u32,
    #[prost(uint32, tag = "3")]
    pub write_timeout_ms: u32,
    /// Connection pool
    #[prost(uint32, tag = "4")]
    pub max_connections: u32,
    #[prost(uint32, tag = "5")]
    pub max_idle_connections: u32,
    /// TLS settings
    #[prost(message, optional, tag = "6")]
    pub tls: ::core::option::Option<TlsSettings>,
    /// Proxy protocol version (0 = disabled, 1, 2)
    #[prost(uint32, tag = "7")]
    pub proxy_protocol: u32,
    /// Custom headers to add
    #[prost(map = "string, string", tag = "8")]
    pub headers: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// TLS settings for origin connection
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TlsSettings {
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    #[prost(bool, tag = "2")]
    pub verify_certificate: bool,
    /// Server Name Indication
    #[prost(string, tag = "3")]
    pub sni: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub ca_certificates: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "5")]
    pub client_certificate: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub client_key: ::prost::alloc::string::String,
}
/// Load balancer configuration
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoadBalancerConfig {
    #[prost(enumeration = "LoadBalancerAlgorithm", tag = "1")]
    pub algorithm: i32,
    /// Sticky sessions
    #[prost(bool, tag = "2")]
    pub sticky_sessions: bool,
    #[prost(string, tag = "3")]
    pub sticky_cookie_name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "4")]
    pub sticky_ttl_seconds: u32,
    /// Health-based routing
    #[prost(bool, tag = "5")]
    pub route_to_healthy_only: bool,
}
/// Health check configuration
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthCheckConfig {
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    #[prost(uint32, tag = "2")]
    pub interval_seconds: u32,
    #[prost(uint32, tag = "3")]
    pub timeout_seconds: u32,
    #[prost(uint32, tag = "4")]
    pub healthy_threshold: u32,
    #[prost(uint32, tag = "5")]
    pub unhealthy_threshold: u32,
    /// Protocol-specific check
    #[prost(oneof = "health_check_config::Check", tags = "6, 7, 8")]
    pub check: ::core::option::Option<health_check_config::Check>,
}
/// Nested message and enum types in `HealthCheckConfig`.
pub mod health_check_config {
    /// Protocol-specific check
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Check {
        #[prost(message, tag = "6")]
        Tcp(super::TcpHealthCheck),
        #[prost(message, tag = "7")]
        Http(super::HttpHealthCheck),
        #[prost(message, tag = "8")]
        Minecraft(super::MinecraftHealthCheck),
    }
}
/// TCP health check
///
/// Just connection check
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TcpHealthCheck {}
/// HTTP health check
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpHealthCheck {
    #[prost(string, tag = "1")]
    pub method: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "3")]
    pub headers: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(uint32, repeated, tag = "4")]
    pub expected_status_codes: ::prost::alloc::vec::Vec<u32>,
    #[prost(string, tag = "5")]
    pub expected_body_contains: ::prost::alloc::string::String,
}
/// Minecraft health check
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MinecraftHealthCheck {
    /// Query server status
    #[prost(bool, tag = "1")]
    pub query_status: bool,
    #[prost(uint32, tag = "2")]
    pub expected_max_players: u32,
}
/// Protection settings for backend
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtectionSettings {
    /// Enable protection
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    /// Protection level
    #[prost(enumeration = "ProtectionLevel", tag = "2")]
    pub level: i32,
    /// Global rate limits
    #[prost(message, optional, tag = "3")]
    pub global_rate_limit: ::core::option::Option<super::common::RateLimit>,
    #[prost(message, optional, tag = "4")]
    pub per_ip_rate_limit: ::core::option::Option<super::common::RateLimit>,
    /// Challenge settings
    #[prost(message, optional, tag = "5")]
    pub challenge: ::core::option::Option<ChallengeSettings>,
    /// GeoIP settings
    #[prost(message, optional, tag = "6")]
    pub geo_ip: ::core::option::Option<GeoIpSettings>,
    /// L7 specific settings
    #[prost(message, optional, tag = "7")]
    pub l7_settings: ::core::option::Option<L7ProtectionSettings>,
}
/// Challenge settings
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChallengeSettings {
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    #[prost(enumeration = "ChallengeType", tag = "2")]
    pub r#type: i32,
    /// 1-10
    #[prost(uint32, tag = "3")]
    pub difficulty: u32,
    #[prost(uint32, tag = "4")]
    pub validity_seconds: u32,
}
/// GeoIP settings
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeoIpSettings {
    #[prost(enumeration = "GeoIpMode", tag = "1")]
    pub mode: i32,
    /// ISO country codes
    #[prost(string, repeated, tag = "2")]
    pub countries: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// L7 protection settings
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct L7ProtectionSettings {
    /// HTTP specific
    #[prost(message, optional, tag = "1")]
    pub http: ::core::option::Option<HttpProtectionSettings>,
    /// Minecraft specific
    #[prost(message, optional, tag = "2")]
    pub minecraft: ::core::option::Option<MinecraftProtectionSettings>,
}
/// HTTP protection settings
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpProtectionSettings {
    /// WAF rules
    #[prost(bool, tag = "1")]
    pub waf_enabled: bool,
    #[prost(enumeration = "WafMode", tag = "2")]
    pub waf_mode: i32,
    /// Bot protection
    #[prost(bool, tag = "3")]
    pub bot_protection: bool,
    #[prost(enumeration = "BotProtectionMode", tag = "4")]
    pub bot_mode: i32,
    /// Request limits
    #[prost(uint64, tag = "5")]
    pub max_request_body_size: u64,
    #[prost(uint32, tag = "6")]
    pub max_requests_per_connection: u32,
    /// Headers
    #[prost(bool, tag = "7")]
    pub hide_server_header: bool,
    #[prost(map = "string, string", tag = "8")]
    pub security_headers: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Minecraft protection settings
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MinecraftProtectionSettings {
    /// Handshake validation
    #[prost(bool, tag = "1")]
    pub validate_handshake: bool,
    /// Status ping protection
    #[prost(bool, tag = "2")]
    pub protect_status: bool,
    #[prost(uint32, tag = "3")]
    pub status_rate_limit: u32,
    /// Player limits
    #[prost(uint32, tag = "4")]
    pub max_players_per_ip: u32,
    #[prost(uint32, tag = "5")]
    pub max_connections_per_second: u32,
    /// Query protection
    #[prost(bool, tag = "6")]
    pub protect_query: bool,
    /// Custom motd for challenges
    #[prost(string, tag = "7")]
    pub challenge_motd: ::prost::alloc::string::String,
}
/// Backend status
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackendStatus {
    #[prost(enumeration = "super::common::HealthStatus", tag = "1")]
    pub health: i32,
    #[prost(uint32, tag = "2")]
    pub healthy_origins: u32,
    #[prost(uint32, tag = "3")]
    pub total_origins: u32,
    /// Traffic stats
    #[prost(uint64, tag = "4")]
    pub requests_per_second: u64,
    #[prost(uint64, tag = "5")]
    pub bytes_per_second: u64,
    /// Attack status
    #[prost(bool, tag = "6")]
    pub under_attack: bool,
    #[prost(string, tag = "7")]
    pub attack_type: ::prost::alloc::string::String,
    /// Packets per second
    #[prost(uint64, tag = "8")]
    pub attack_pps: u64,
    /// Last status update
    #[prost(message, optional, tag = "9")]
    pub last_updated: ::core::option::Option<super::common::Timestamp>,
}
/// Request/Response messages
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBackendRequest {
    #[prost(string, tag = "1")]
    pub organization_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub backend: ::core::option::Option<Backend>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBackendResponse {
    #[prost(message, optional, tag = "1")]
    pub backend: ::core::option::Option<Backend>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBackendRequest {
    #[prost(string, tag = "1")]
    pub backend_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBackendResponse {
    #[prost(message, optional, tag = "1")]
    pub backend: ::core::option::Option<Backend>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBackendRequest {
    #[prost(message, optional, tag = "1")]
    pub backend: ::core::option::Option<Backend>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBackendResponse {
    #[prost(message, optional, tag = "1")]
    pub backend: ::core::option::Option<Backend>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteBackendRequest {
    #[prost(string, tag = "1")]
    pub backend_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteBackendResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBackendsRequest {
    #[prost(string, tag = "1")]
    pub organization_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<super::common::Pagination>,
    #[prost(enumeration = "BackendType", tag = "3")]
    pub type_filter: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBackendsResponse {
    #[prost(message, repeated, tag = "1")]
    pub backends: ::prost::alloc::vec::Vec<Backend>,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<super::common::PaginationInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddOriginRequest {
    #[prost(string, tag = "1")]
    pub backend_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub origin: ::core::option::Option<Origin>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddOriginResponse {
    #[prost(message, optional, tag = "1")]
    pub origin: ::core::option::Option<Origin>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateOriginRequest {
    #[prost(string, tag = "1")]
    pub backend_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub origin: ::core::option::Option<Origin>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateOriginResponse {
    #[prost(message, optional, tag = "1")]
    pub origin: ::core::option::Option<Origin>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveOriginRequest {
    #[prost(string, tag = "1")]
    pub backend_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub origin_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveOriginResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateProtectionRequest {
    #[prost(string, tag = "1")]
    pub backend_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub protection: ::core::option::Option<ProtectionSettings>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateProtectionResponse {
    #[prost(message, optional, tag = "1")]
    pub protection: ::core::option::Option<ProtectionSettings>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetProtectionLevelRequest {
    #[prost(string, tag = "1")]
    pub backend_id: ::prost::alloc::string::String,
    #[prost(enumeration = "ProtectionLevel", tag = "2")]
    pub level: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetProtectionLevelResponse {
    #[prost(enumeration = "ProtectionLevel", tag = "1")]
    pub level: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBackendStatusRequest {
    #[prost(string, tag = "1")]
    pub backend_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBackendStatusResponse {
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<BackendStatus>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WatchBackendStatusRequest {
    #[prost(string, tag = "1")]
    pub backend_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddDomainRequest {
    #[prost(string, tag = "1")]
    pub backend_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub domain: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddDomainResponse {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub verification_token: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub verification_method: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveDomainRequest {
    #[prost(string, tag = "1")]
    pub backend_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub domain: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveDomainResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerifyDomainRequest {
    #[prost(string, tag = "1")]
    pub backend_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub domain: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerifyDomainResponse {
    #[prost(bool, tag = "1")]
    pub verified: bool,
    #[prost(string, tag = "2")]
    pub error: ::prost::alloc::string::String,
}
/// Backend type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BackendType {
    Unspecified = 0,
    Http = 1,
    Https = 2,
    Tcp = 3,
    Udp = 4,
    MinecraftJava = 5,
    MinecraftBedrock = 6,
    Quic = 7,
}
impl BackendType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "BACKEND_TYPE_UNSPECIFIED",
            Self::Http => "BACKEND_TYPE_HTTP",
            Self::Https => "BACKEND_TYPE_HTTPS",
            Self::Tcp => "BACKEND_TYPE_TCP",
            Self::Udp => "BACKEND_TYPE_UDP",
            Self::MinecraftJava => "BACKEND_TYPE_MINECRAFT_JAVA",
            Self::MinecraftBedrock => "BACKEND_TYPE_MINECRAFT_BEDROCK",
            Self::Quic => "BACKEND_TYPE_QUIC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BACKEND_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "BACKEND_TYPE_HTTP" => Some(Self::Http),
            "BACKEND_TYPE_HTTPS" => Some(Self::Https),
            "BACKEND_TYPE_TCP" => Some(Self::Tcp),
            "BACKEND_TYPE_UDP" => Some(Self::Udp),
            "BACKEND_TYPE_MINECRAFT_JAVA" => Some(Self::MinecraftJava),
            "BACKEND_TYPE_MINECRAFT_BEDROCK" => Some(Self::MinecraftBedrock),
            "BACKEND_TYPE_QUIC" => Some(Self::Quic),
            _ => None,
        }
    }
}
/// Load balancing algorithm
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LoadBalancerAlgorithm {
    Unspecified = 0,
    RoundRobin = 1,
    LeastConnections = 2,
    Random = 3,
    IpHash = 4,
    Weighted = 5,
}
impl LoadBalancerAlgorithm {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "LOAD_BALANCER_ALGORITHM_UNSPECIFIED",
            Self::RoundRobin => "LOAD_BALANCER_ALGORITHM_ROUND_ROBIN",
            Self::LeastConnections => "LOAD_BALANCER_ALGORITHM_LEAST_CONNECTIONS",
            Self::Random => "LOAD_BALANCER_ALGORITHM_RANDOM",
            Self::IpHash => "LOAD_BALANCER_ALGORITHM_IP_HASH",
            Self::Weighted => "LOAD_BALANCER_ALGORITHM_WEIGHTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LOAD_BALANCER_ALGORITHM_UNSPECIFIED" => Some(Self::Unspecified),
            "LOAD_BALANCER_ALGORITHM_ROUND_ROBIN" => Some(Self::RoundRobin),
            "LOAD_BALANCER_ALGORITHM_LEAST_CONNECTIONS" => Some(Self::LeastConnections),
            "LOAD_BALANCER_ALGORITHM_RANDOM" => Some(Self::Random),
            "LOAD_BALANCER_ALGORITHM_IP_HASH" => Some(Self::IpHash),
            "LOAD_BALANCER_ALGORITHM_WEIGHTED" => Some(Self::Weighted),
            _ => None,
        }
    }
}
/// Protection level
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProtectionLevel {
    Unspecified = 0,
    Off = 1,
    Low = 2,
    Medium = 3,
    High = 4,
    UnderAttack = 5,
}
impl ProtectionLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PROTECTION_LEVEL_UNSPECIFIED",
            Self::Off => "PROTECTION_LEVEL_OFF",
            Self::Low => "PROTECTION_LEVEL_LOW",
            Self::Medium => "PROTECTION_LEVEL_MEDIUM",
            Self::High => "PROTECTION_LEVEL_HIGH",
            Self::UnderAttack => "PROTECTION_LEVEL_UNDER_ATTACK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROTECTION_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
            "PROTECTION_LEVEL_OFF" => Some(Self::Off),
            "PROTECTION_LEVEL_LOW" => Some(Self::Low),
            "PROTECTION_LEVEL_MEDIUM" => Some(Self::Medium),
            "PROTECTION_LEVEL_HIGH" => Some(Self::High),
            "PROTECTION_LEVEL_UNDER_ATTACK" => Some(Self::UnderAttack),
            _ => None,
        }
    }
}
/// Challenge types
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChallengeType {
    Unspecified = 0,
    Javascript = 1,
    Captcha = 2,
    /// Proof of work
    Pow = 3,
}
impl ChallengeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CHALLENGE_TYPE_UNSPECIFIED",
            Self::Javascript => "CHALLENGE_TYPE_JAVASCRIPT",
            Self::Captcha => "CHALLENGE_TYPE_CAPTCHA",
            Self::Pow => "CHALLENGE_TYPE_POW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHALLENGE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "CHALLENGE_TYPE_JAVASCRIPT" => Some(Self::Javascript),
            "CHALLENGE_TYPE_CAPTCHA" => Some(Self::Captcha),
            "CHALLENGE_TYPE_POW" => Some(Self::Pow),
            _ => None,
        }
    }
}
/// GeoIP filtering mode
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GeoIpMode {
    Unspecified = 0,
    Disabled = 1,
    AllowList = 2,
    BlockList = 3,
}
impl GeoIpMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "GEO_IP_MODE_UNSPECIFIED",
            Self::Disabled => "GEO_IP_MODE_DISABLED",
            Self::AllowList => "GEO_IP_MODE_ALLOW_LIST",
            Self::BlockList => "GEO_IP_MODE_BLOCK_LIST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GEO_IP_MODE_UNSPECIFIED" => Some(Self::Unspecified),
            "GEO_IP_MODE_DISABLED" => Some(Self::Disabled),
            "GEO_IP_MODE_ALLOW_LIST" => Some(Self::AllowList),
            "GEO_IP_MODE_BLOCK_LIST" => Some(Self::BlockList),
            _ => None,
        }
    }
}
/// WAF mode
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WafMode {
    Unspecified = 0,
    Detect = 1,
    Block = 2,
}
impl WafMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "WAF_MODE_UNSPECIFIED",
            Self::Detect => "WAF_MODE_DETECT",
            Self::Block => "WAF_MODE_BLOCK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WAF_MODE_UNSPECIFIED" => Some(Self::Unspecified),
            "WAF_MODE_DETECT" => Some(Self::Detect),
            "WAF_MODE_BLOCK" => Some(Self::Block),
            _ => None,
        }
    }
}
/// Bot protection mode
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BotProtectionMode {
    Unspecified = 0,
    AllowAll = 1,
    ChallengeSuspicious = 2,
    BlockAllBots = 3,
}
impl BotProtectionMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "BOT_PROTECTION_MODE_UNSPECIFIED",
            Self::AllowAll => "BOT_PROTECTION_MODE_ALLOW_ALL",
            Self::ChallengeSuspicious => "BOT_PROTECTION_MODE_CHALLENGE_SUSPICIOUS",
            Self::BlockAllBots => "BOT_PROTECTION_MODE_BLOCK_ALL_BOTS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BOT_PROTECTION_MODE_UNSPECIFIED" => Some(Self::Unspecified),
            "BOT_PROTECTION_MODE_ALLOW_ALL" => Some(Self::AllowAll),
            "BOT_PROTECTION_MODE_CHALLENGE_SUSPICIOUS" => Some(Self::ChallengeSuspicious),
            "BOT_PROTECTION_MODE_BLOCK_ALL_BOTS" => Some(Self::BlockAllBots),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod backend_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Backend service
    #[derive(Debug, Clone)]
    pub struct BackendServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl BackendServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> BackendServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> BackendServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            BackendServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Backend management
        pub async fn create_backend(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateBackendRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateBackendResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.backend.BackendService/CreateBackend",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pistonprotection.backend.BackendService",
                        "CreateBackend",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_backend(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBackendRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBackendResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.backend.BackendService/GetBackend",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pistonprotection.backend.BackendService",
                        "GetBackend",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_backend(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateBackendRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateBackendResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.backend.BackendService/UpdateBackend",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pistonprotection.backend.BackendService",
                        "UpdateBackend",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_backend(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteBackendRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteBackendResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.backend.BackendService/DeleteBackend",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pistonprotection.backend.BackendService",
                        "DeleteBackend",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn list_backends(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBackendsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBackendsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.backend.BackendService/ListBackends",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pistonprotection.backend.BackendService",
                        "ListBackends",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Origin management
        pub async fn add_origin(
            &mut self,
            request: impl tonic::IntoRequest<super::AddOriginRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AddOriginResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.backend.BackendService/AddOrigin",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pistonprotection.backend.BackendService",
                        "AddOrigin",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_origin(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateOriginRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateOriginResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.backend.BackendService/UpdateOrigin",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pistonprotection.backend.BackendService",
                        "UpdateOrigin",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn remove_origin(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveOriginRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RemoveOriginResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.backend.BackendService/RemoveOrigin",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pistonprotection.backend.BackendService",
                        "RemoveOrigin",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Protection settings
        pub async fn update_protection(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateProtectionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateProtectionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.backend.BackendService/UpdateProtection",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pistonprotection.backend.BackendService",
                        "UpdateProtection",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn set_protection_level(
            &mut self,
            request: impl tonic::IntoRequest<super::SetProtectionLevelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetProtectionLevelResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.backend.BackendService/SetProtectionLevel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pistonprotection.backend.BackendService",
                        "SetProtectionLevel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Status
        pub async fn get_backend_status(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBackendStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBackendStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.backend.BackendService/GetBackendStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pistonprotection.backend.BackendService",
                        "GetBackendStatus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn watch_backend_status(
            &mut self,
            request: impl tonic::IntoRequest<super::WatchBackendStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::BackendStatus>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.backend.BackendService/WatchBackendStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pistonprotection.backend.BackendService",
                        "WatchBackendStatus",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Domain management
        pub async fn add_domain(
            &mut self,
            request: impl tonic::IntoRequest<super::AddDomainRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AddDomainResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.backend.BackendService/AddDomain",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pistonprotection.backend.BackendService",
                        "AddDomain",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn remove_domain(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveDomainRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RemoveDomainResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.backend.BackendService/RemoveDomain",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pistonprotection.backend.BackendService",
                        "RemoveDomain",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn verify_domain(
            &mut self,
            request: impl tonic::IntoRequest<super::VerifyDomainRequest>,
        ) -> std::result::Result<
            tonic::Response<super::VerifyDomainResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pistonprotection.backend.BackendService/VerifyDomain",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pistonprotection.backend.BackendService",
                        "VerifyDomain",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod backend_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with BackendServiceServer.
    #[async_trait]
    pub trait BackendService: std::marker::Send + std::marker::Sync + 'static {
        /// Backend management
        async fn create_backend(
            &self,
            request: tonic::Request<super::CreateBackendRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateBackendResponse>,
            tonic::Status,
        >;
        async fn get_backend(
            &self,
            request: tonic::Request<super::GetBackendRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBackendResponse>,
            tonic::Status,
        >;
        async fn update_backend(
            &self,
            request: tonic::Request<super::UpdateBackendRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateBackendResponse>,
            tonic::Status,
        >;
        async fn delete_backend(
            &self,
            request: tonic::Request<super::DeleteBackendRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteBackendResponse>,
            tonic::Status,
        >;
        async fn list_backends(
            &self,
            request: tonic::Request<super::ListBackendsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBackendsResponse>,
            tonic::Status,
        >;
        /// Origin management
        async fn add_origin(
            &self,
            request: tonic::Request<super::AddOriginRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AddOriginResponse>,
            tonic::Status,
        >;
        async fn update_origin(
            &self,
            request: tonic::Request<super::UpdateOriginRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateOriginResponse>,
            tonic::Status,
        >;
        async fn remove_origin(
            &self,
            request: tonic::Request<super::RemoveOriginRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RemoveOriginResponse>,
            tonic::Status,
        >;
        /// Protection settings
        async fn update_protection(
            &self,
            request: tonic::Request<super::UpdateProtectionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateProtectionResponse>,
            tonic::Status,
        >;
        async fn set_protection_level(
            &self,
            request: tonic::Request<super::SetProtectionLevelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetProtectionLevelResponse>,
            tonic::Status,
        >;
        /// Status
        async fn get_backend_status(
            &self,
            request: tonic::Request<super::GetBackendStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBackendStatusResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the WatchBackendStatus method.
        type WatchBackendStatusStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::BackendStatus, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn watch_backend_status(
            &self,
            request: tonic::Request<super::WatchBackendStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::WatchBackendStatusStream>,
            tonic::Status,
        >;
        /// Domain management
        async fn add_domain(
            &self,
            request: tonic::Request<super::AddDomainRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AddDomainResponse>,
            tonic::Status,
        >;
        async fn remove_domain(
            &self,
            request: tonic::Request<super::RemoveDomainRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RemoveDomainResponse>,
            tonic::Status,
        >;
        async fn verify_domain(
            &self,
            request: tonic::Request<super::VerifyDomainRequest>,
        ) -> std::result::Result<
            tonic::Response<super::VerifyDomainResponse>,
            tonic::Status,
        >;
    }
    /// Backend service
    #[derive(Debug)]
    pub struct BackendServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> BackendServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for BackendServiceServer<T>
    where
        T: BackendService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/pistonprotection.backend.BackendService/CreateBackend" => {
                    #[allow(non_camel_case_types)]
                    struct CreateBackendSvc<T: BackendService>(pub Arc<T>);
                    impl<
                        T: BackendService,
                    > tonic::server::UnaryService<super::CreateBackendRequest>
                    for CreateBackendSvc<T> {
                        type Response = super::CreateBackendResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateBackendRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BackendService>::create_backend(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateBackendSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pistonprotection.backend.BackendService/GetBackend" => {
                    #[allow(non_camel_case_types)]
                    struct GetBackendSvc<T: BackendService>(pub Arc<T>);
                    impl<
                        T: BackendService,
                    > tonic::server::UnaryService<super::GetBackendRequest>
                    for GetBackendSvc<T> {
                        type Response = super::GetBackendResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetBackendRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BackendService>::get_backend(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetBackendSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pistonprotection.backend.BackendService/UpdateBackend" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateBackendSvc<T: BackendService>(pub Arc<T>);
                    impl<
                        T: BackendService,
                    > tonic::server::UnaryService<super::UpdateBackendRequest>
                    for UpdateBackendSvc<T> {
                        type Response = super::UpdateBackendResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateBackendRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BackendService>::update_backend(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateBackendSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pistonprotection.backend.BackendService/DeleteBackend" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteBackendSvc<T: BackendService>(pub Arc<T>);
                    impl<
                        T: BackendService,
                    > tonic::server::UnaryService<super::DeleteBackendRequest>
                    for DeleteBackendSvc<T> {
                        type Response = super::DeleteBackendResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteBackendRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BackendService>::delete_backend(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteBackendSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pistonprotection.backend.BackendService/ListBackends" => {
                    #[allow(non_camel_case_types)]
                    struct ListBackendsSvc<T: BackendService>(pub Arc<T>);
                    impl<
                        T: BackendService,
                    > tonic::server::UnaryService<super::ListBackendsRequest>
                    for ListBackendsSvc<T> {
                        type Response = super::ListBackendsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListBackendsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BackendService>::list_backends(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListBackendsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pistonprotection.backend.BackendService/AddOrigin" => {
                    #[allow(non_camel_case_types)]
                    struct AddOriginSvc<T: BackendService>(pub Arc<T>);
                    impl<
                        T: BackendService,
                    > tonic::server::UnaryService<super::AddOriginRequest>
                    for AddOriginSvc<T> {
                        type Response = super::AddOriginResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AddOriginRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BackendService>::add_origin(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddOriginSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pistonprotection.backend.BackendService/UpdateOrigin" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateOriginSvc<T: BackendService>(pub Arc<T>);
                    impl<
                        T: BackendService,
                    > tonic::server::UnaryService<super::UpdateOriginRequest>
                    for UpdateOriginSvc<T> {
                        type Response = super::UpdateOriginResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateOriginRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BackendService>::update_origin(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateOriginSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pistonprotection.backend.BackendService/RemoveOrigin" => {
                    #[allow(non_camel_case_types)]
                    struct RemoveOriginSvc<T: BackendService>(pub Arc<T>);
                    impl<
                        T: BackendService,
                    > tonic::server::UnaryService<super::RemoveOriginRequest>
                    for RemoveOriginSvc<T> {
                        type Response = super::RemoveOriginResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RemoveOriginRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BackendService>::remove_origin(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RemoveOriginSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pistonprotection.backend.BackendService/UpdateProtection" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateProtectionSvc<T: BackendService>(pub Arc<T>);
                    impl<
                        T: BackendService,
                    > tonic::server::UnaryService<super::UpdateProtectionRequest>
                    for UpdateProtectionSvc<T> {
                        type Response = super::UpdateProtectionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateProtectionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BackendService>::update_protection(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateProtectionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pistonprotection.backend.BackendService/SetProtectionLevel" => {
                    #[allow(non_camel_case_types)]
                    struct SetProtectionLevelSvc<T: BackendService>(pub Arc<T>);
                    impl<
                        T: BackendService,
                    > tonic::server::UnaryService<super::SetProtectionLevelRequest>
                    for SetProtectionLevelSvc<T> {
                        type Response = super::SetProtectionLevelResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetProtectionLevelRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BackendService>::set_protection_level(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetProtectionLevelSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pistonprotection.backend.BackendService/GetBackendStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetBackendStatusSvc<T: BackendService>(pub Arc<T>);
                    impl<
                        T: BackendService,
                    > tonic::server::UnaryService<super::GetBackendStatusRequest>
                    for GetBackendStatusSvc<T> {
                        type Response = super::GetBackendStatusResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetBackendStatusRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BackendService>::get_backend_status(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetBackendStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pistonprotection.backend.BackendService/WatchBackendStatus" => {
                    #[allow(non_camel_case_types)]
                    struct WatchBackendStatusSvc<T: BackendService>(pub Arc<T>);
                    impl<
                        T: BackendService,
                    > tonic::server::ServerStreamingService<
                        super::WatchBackendStatusRequest,
                    > for WatchBackendStatusSvc<T> {
                        type Response = super::BackendStatus;
                        type ResponseStream = T::WatchBackendStatusStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::WatchBackendStatusRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BackendService>::watch_backend_status(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = WatchBackendStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pistonprotection.backend.BackendService/AddDomain" => {
                    #[allow(non_camel_case_types)]
                    struct AddDomainSvc<T: BackendService>(pub Arc<T>);
                    impl<
                        T: BackendService,
                    > tonic::server::UnaryService<super::AddDomainRequest>
                    for AddDomainSvc<T> {
                        type Response = super::AddDomainResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AddDomainRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BackendService>::add_domain(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddDomainSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pistonprotection.backend.BackendService/RemoveDomain" => {
                    #[allow(non_camel_case_types)]
                    struct RemoveDomainSvc<T: BackendService>(pub Arc<T>);
                    impl<
                        T: BackendService,
                    > tonic::server::UnaryService<super::RemoveDomainRequest>
                    for RemoveDomainSvc<T> {
                        type Response = super::RemoveDomainResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RemoveDomainRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BackendService>::remove_domain(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RemoveDomainSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pistonprotection.backend.BackendService/VerifyDomain" => {
                    #[allow(non_camel_case_types)]
                    struct VerifyDomainSvc<T: BackendService>(pub Arc<T>);
                    impl<
                        T: BackendService,
                    > tonic::server::UnaryService<super::VerifyDomainRequest>
                    for VerifyDomainSvc<T> {
                        type Response = super::VerifyDomainResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VerifyDomainRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BackendService>::verify_domain(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = VerifyDomainSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for BackendServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "pistonprotection.backend.BackendService";
    impl<T> tonic::server::NamedService for BackendServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
