// This file is @generated by prost-build.
/// Timestamp in nanoseconds since epoch
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Timestamp {
    #[prost(int64, tag = "1")]
    pub seconds: i64,
    #[prost(int32, tag = "2")]
    pub nanos: i32,
}
/// IP address (supports both IPv4 and IPv6)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpAddress {
    #[prost(oneof = "ip_address::Address", tags = "1, 2")]
    pub address: ::core::option::Option<ip_address::Address>,
}
/// Nested message and enum types in `IPAddress`.
pub mod ip_address {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Address {
        #[prost(fixed32, tag = "1")]
        Ipv4(u32),
        /// 16 bytes for IPv6
        #[prost(bytes, tag = "2")]
        Ipv6(::prost::alloc::vec::Vec<u8>),
    }
}
/// IP network (CIDR)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpNetwork {
    #[prost(message, optional, tag = "1")]
    pub address: ::core::option::Option<IpAddress>,
    #[prost(uint32, tag = "2")]
    pub prefix_length: u32,
}
/// Port range
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PortRange {
    #[prost(uint32, tag = "1")]
    pub start: u32,
    #[prost(uint32, tag = "2")]
    pub end: u32,
}
/// GeoIP country code (ISO 3166-1 alpha-2)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeoLocation {
    #[prost(string, tag = "1")]
    pub country_code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub city: ::prost::alloc::string::String,
    #[prost(float, tag = "4")]
    pub latitude: f32,
    #[prost(float, tag = "5")]
    pub longitude: f32,
}
/// Rate limit configuration
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RateLimit {
    #[prost(uint64, tag = "1")]
    pub requests_per_second: u64,
    #[prost(uint64, tag = "2")]
    pub burst_size: u64,
    #[prost(uint32, tag = "3")]
    pub window_seconds: u32,
}
/// Pagination for list requests
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Pagination {
    #[prost(uint32, tag = "1")]
    pub page: u32,
    #[prost(uint32, tag = "2")]
    pub page_size: u32,
    #[prost(string, tag = "3")]
    pub cursor: ::prost::alloc::string::String,
}
/// Pagination response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaginationInfo {
    #[prost(uint32, tag = "1")]
    pub total_count: u32,
    #[prost(uint32, tag = "2")]
    pub page: u32,
    #[prost(uint32, tag = "3")]
    pub page_size: u32,
    #[prost(bool, tag = "4")]
    pub has_next: bool,
    #[prost(string, tag = "5")]
    pub next_cursor: ::prost::alloc::string::String,
}
/// Error details
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Error {
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "3")]
    pub details: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// UUID wrapper
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Uuid {
    #[prost(string, tag = "1")]
    pub value: ::prost::alloc::string::String,
}
/// Protocol type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Protocol {
    Unspecified = 0,
    Tcp = 1,
    Udp = 2,
    Icmp = 3,
}
impl Protocol {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PROTOCOL_UNSPECIFIED",
            Self::Tcp => "PROTOCOL_TCP",
            Self::Udp => "PROTOCOL_UDP",
            Self::Icmp => "PROTOCOL_ICMP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROTOCOL_UNSPECIFIED" => Some(Self::Unspecified),
            "PROTOCOL_TCP" => Some(Self::Tcp),
            "PROTOCOL_UDP" => Some(Self::Udp),
            "PROTOCOL_ICMP" => Some(Self::Icmp),
            _ => None,
        }
    }
}
/// L7 Protocol type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum L7Protocol {
    Unspecified = 0,
    Http = 1,
    Http2 = 2,
    Http3 = 3,
    Quic = 4,
    MinecraftJava = 5,
    MinecraftBedrock = 6,
    GenericTcp = 7,
    GenericUdp = 8,
}
impl L7Protocol {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "L7_PROTOCOL_UNSPECIFIED",
            Self::Http => "L7_PROTOCOL_HTTP",
            Self::Http2 => "L7_PROTOCOL_HTTP2",
            Self::Http3 => "L7_PROTOCOL_HTTP3",
            Self::Quic => "L7_PROTOCOL_QUIC",
            Self::MinecraftJava => "L7_PROTOCOL_MINECRAFT_JAVA",
            Self::MinecraftBedrock => "L7_PROTOCOL_MINECRAFT_BEDROCK",
            Self::GenericTcp => "L7_PROTOCOL_GENERIC_TCP",
            Self::GenericUdp => "L7_PROTOCOL_GENERIC_UDP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "L7_PROTOCOL_UNSPECIFIED" => Some(Self::Unspecified),
            "L7_PROTOCOL_HTTP" => Some(Self::Http),
            "L7_PROTOCOL_HTTP2" => Some(Self::Http2),
            "L7_PROTOCOL_HTTP3" => Some(Self::Http3),
            "L7_PROTOCOL_QUIC" => Some(Self::Quic),
            "L7_PROTOCOL_MINECRAFT_JAVA" => Some(Self::MinecraftJava),
            "L7_PROTOCOL_MINECRAFT_BEDROCK" => Some(Self::MinecraftBedrock),
            "L7_PROTOCOL_GENERIC_TCP" => Some(Self::GenericTcp),
            "L7_PROTOCOL_GENERIC_UDP" => Some(Self::GenericUdp),
            _ => None,
        }
    }
}
/// Action to take on matching traffic
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Action {
    Unspecified = 0,
    Allow = 1,
    Drop = 2,
    RateLimit = 3,
    /// L7 challenge-response
    Challenge = 4,
    Log = 5,
    /// Redirect to honeypot
    Redirect = 6,
}
impl Action {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ACTION_UNSPECIFIED",
            Self::Allow => "ACTION_ALLOW",
            Self::Drop => "ACTION_DROP",
            Self::RateLimit => "ACTION_RATE_LIMIT",
            Self::Challenge => "ACTION_CHALLENGE",
            Self::Log => "ACTION_LOG",
            Self::Redirect => "ACTION_REDIRECT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACTION_UNSPECIFIED" => Some(Self::Unspecified),
            "ACTION_ALLOW" => Some(Self::Allow),
            "ACTION_DROP" => Some(Self::Drop),
            "ACTION_RATE_LIMIT" => Some(Self::RateLimit),
            "ACTION_CHALLENGE" => Some(Self::Challenge),
            "ACTION_LOG" => Some(Self::Log),
            "ACTION_REDIRECT" => Some(Self::Redirect),
            _ => None,
        }
    }
}
/// Health status
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HealthStatus {
    Unspecified = 0,
    Healthy = 1,
    Degraded = 2,
    Unhealthy = 3,
}
impl HealthStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "HEALTH_STATUS_UNSPECIFIED",
            Self::Healthy => "HEALTH_STATUS_HEALTHY",
            Self::Degraded => "HEALTH_STATUS_DEGRADED",
            Self::Unhealthy => "HEALTH_STATUS_UNHEALTHY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HEALTH_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "HEALTH_STATUS_HEALTHY" => Some(Self::Healthy),
            "HEALTH_STATUS_DEGRADED" => Some(Self::Degraded),
            "HEALTH_STATUS_UNHEALTHY" => Some(Self::Unhealthy),
            _ => None,
        }
    }
}
